# program flow for train/predict/chain:
# 1) call train/predict/chain (implemented in Lrnr_base)
# 2) call delayed_train/delayed_predict/delayed_chain  (implemented at the package level, delayed version of:base_train/base_predict/base_chain)
# 3) call .train/.predict/.chain (implemented in Lrnr subclasses)
# 4) for user facing train/predict/chain call delayed_obj$compute



#' Base Class for all sl3 learners.
#'
#' Generally this base Learner class shouldn't be instantiated. It's intended to be an abstract class, although abstract classes aren't explicitly supported by R6.
#' @docType class
#' @importFrom R6 R6Class
#' @export
#' @keywords data
#' @return \code{\link{Lrnr_base}} object with methods for training and prediction
#' @format \code{\link{R6Class}} object.
#' @field params A list of parameters needed to fully specify the learner. This includes things like model hyperparameters.
#' @field is_trained A boolean indicating that the learner has been already trained.
#' @field name A short name used to reference predictions from this class
#' @section Methods:
#' \describe{
#'   \item{\code{new(...)}}{This method is used to create an object of this class.}
#'   \item{\code{train(task)}}{Trains this Learner on the data in the \code{task} object. Returns a new \code{Learner} object containing the fit of this Learner to the data in \code{task}. This can then be used with the \code{predict} and \code{chain} methods.}
#'   \item{\code{predict(task=NULL)}}{When called from a \code{Learner} object generated by a call to \code{train}, can be used to generate predictions on the data in \code{task}. If no \code{task} is specified, the task used to train the Learner will be used.}
#'   \item{\code{chain(task=NULL)}}{When called from a \code{Learner} object generated by a call to \code{train}, will generate a new task based on the pre be used to generate predictions on the data in \code{task}. This can be used to train a new Learner on the output of this one. This is mostly accomplished by using \code{\link{Pipeline}} Learner. If no \code{task} is specified, the task used to train the Learner will be used.}
#'   }
#' @importFrom assertthat assert_that is.count is.flag
#' @importFrom uuid UUIDgenerate
#' @importFrom memoise memoise cache_memory cache_filesystem
#' @importFrom BBmisc requirePackages
#' @family Learners
Lrnr_base <- R6Class(classname = "Lrnr_base",
                     portable = TRUE,
                     class = TRUE,
                     public = list(
                       initialize = function(params=NULL, ...) {
                         private$.load_packages()
                         if(is.null(params)){
                           params=list(...)
                         }
                         
                         private$.params=params
                         private$.learner_uuid = UUIDgenerate(use.time=T)
                         
                         
                         invisible(self)
                       },
                       subset_covariates = function(task){
                         # allows learners to use only a subset of covariates
                         if ("covariates" %in% names(self$params) && !is.null(self$params[["covariates"]])) {
                           task_covariates <- task$nodes$covariates
                           subset_covariates <- intersect(task_covariates, self$params$covariates)
                           return(task$next_in_chain(covariates=subset_covariates))
                         } else {
                           return(task)
                         }
                         
                         
                       },
                       base_train = function(task, pretrain = NULL) {
                         #trains learner to data
                         assert_that(is(task,"sl3_Task"))
                         
                         #todo: add error handling
                         subsetted_task = self$subset_covariates(task)
                         if(!is.null(pretrain)){
                          fit_object = private$.train(subsetted_task, pretrain)
                         } else {
                          fit_object = private$.train(subsetted_task) 
                         }
                         new_object = self$clone() # copy parameters, and whatever else
                         new_object$set_train(fit_object, task)
                         
                         return(new_object)
                       },
                       
                       set_train = function(fit_object, training_task){
                         #todo: figure out how to do this without a public method that is mutuating private variables.
                         private$.fit_object = fit_object
                         private$.training_task = training_task
                         private$.fit_uuid = UUIDgenerate(use.time=T)
                         
                       },
                       assert_trained = function(){
                         if(!self$is_trained){
                           stop("Learner has not yet been train to data. Call learner$train(task) first.")
                         }
                       },
                       base_predict = function(task = NULL){
                         self$assert_trained()
                         
                         if(is.null(task)){
                           task <- private$.training_task
                         } else{
                           task <- task$next_in_chain(new_nodes=private$.training_task$nodes)
                         }
                         assert_that(is(task,"sl3_Task"))
                         subsetted_task = self$subset_covariates(task)
                         predictions = private$.predict(subsetted_task)
                         
                         return(predictions)
                       },
                       
                       base_chain = function(task = NULL){
                         self$assert_trained()
                         
                         if(is.null(task)){
                           task <- private$.training_task
                         } else{
                           task <- task$next_in_chain(new_nodes=private$.training_task$nodes)
                         }
                         assert_that(is(task,"sl3_Task"))
                         subsetted_task = self$subset_covariates(task)
                         next_task = private$.chain(subsetted_task)
                         
                         return(next_task)
                         
                       },
                       pretrain = function(task){
                         return(private$.pretrain(task))
                       },
                       train = function(task){
                         delayed_fit <- delayed_learner_train(self, task)
                         return(delayed_fit$compute())
                       },
                       predict = function(task = NULL){
                         delayed_preds <- delayed_learner_fit_predict(self, task)
                         return(delayed_preds$compute())
                       },
                       chain = function(task = NULL){
                         delayed_chained <- delayed_learner_fit_chain(self, task)
                         return(delayed_chained$compute())
                       },
                       print = function(){
                         print(self$name)
                         #print(self$params)
                         fit_object=private$.fit_object
                         if(!is.null(fit_object))
                           print(fit_object)
                       }),
                     
                     active = list(
                       is_trained=function(){
                         return(!is.null(private$.fit_object))
                       },
                       fit_object=function() {
                         fit_object=private$.fit_object
                         return(fit_object)
                       },
                       name=function(){
                         #todo: allow custom names
                         if(is.null(private$.name)){
                           
                           params=self$params
                           if(length(params)>0){
                             #todo: sanitize further
                             atom_params=sapply(params,is.atomic)
                             params=params[atom_params]
                           }
                           props = c(list(class(self)[1]), params)
                           name = paste(props,collapse="_")
                           private$.name = name
                         }
                         
                         return(private$.name)
                       },
                       learner_uuid=function(){
                         return(private$.learner_uuid)
                       },
                       fit_uuid=function(){
                         return(private$.fit_uuid)
                       },
                       params=function(){
                         return(private$.params)
                       },
                       training_task=function(){
                         return(private$.training_task)
                       }
                     ),
                     private = list(
                       .name = NULL,
                       .fit_object = NULL,
                       .training_task = NULL,
                       .learner_uuid = NULL,
                       .fit_uuid = NULL,
                       .params = NULL,
                       .required_packages = NULL,
                       .pretrain = function(task){
                         #nested fits go here
                         return(NULL)
                       },
                       .train = function(task){
                         stop("Learner is meant to be abstract, you should instead use specific learners. See listLearners()")
                       },
                       .predict = function(task){
                         predictions = predict(private$.fit_object, newdata=task$X)
                         return(predictions)
                       },
                       .chain = function(task){
                         predictions = self$predict(task)
                         predictions = as.data.table(predictions)
                         
                         
                         #add predictions as new columns
                         new_col_names = task$add_columns(self$fit_uuid, predictions)
                         
                         return(task$next_in_chain(covariates=new_col_names))
                       },
                       .load_packages = function(){
                         if(!is.null(private$.required_packages)){
                          requirePackages(private$.required_packages, why = class(self)[1], default.method = "load")
                         }
                       }
                     )
)

#todo: implement predict S3 method


print.Learner=function(object){
  object$print()
}