#' Base Class for all sl3 learners.
#'
#' Generally this base Learner class shouldn't be instantiated. It's intended to be an abstract class, although abstract classes aren't explicitly supported by R6.
#' @docType class
#' @importFrom R6 R6Class
#' @export
#' @keywords data
#' @return \code{\link{Learner}} object with methods for training and prediction
#' @format \code{\link{R6Class}} object.
#' @field params A list of parameters needed to fully specify the learner. This includes things like model hyperparameters.
#' @field is_trained A boolean indicating that the learner has been already trained.
#' @field name A short name used to reference predictions from this class
#' @section Methods:
#' \describe{
#'   \item{\code{new(...)}}{This method is used to create an object of this class.}
#'   \item{\code{train(task)}}{Trains this Learner on the data in the \code{task} object. Returns a new \code{Learner} object containing the fit of this Learner to the data in \code{task}. This can then be used with the \code{predict} and \code{chain} methods.}
#'   \item{\code{predict(task=NULL)}}{When called from a \code{Learner} object generated by a call to \code{train}, can be used to generate predictions on the data in \code{task}. If no \code{task} is specified, the task used to train the Learner will be used.}
#'   \item{\code{chain(task=NULL)}}{When called from a \code{Learner} object generated by a call to \code{train}, will generate a new task based on the pre be used to generate predictions on the data in \code{task}. This can be used to train a new Learner on the output of this one. This is mostly accomplished by using \code{\link{Pipeline}} Learner. If no \code{task} is specified, the task used to train the Learner will be used.}
#'   }
#' @importFrom assertthat assert_that is.count is.flag
#' @family Learners
Learner <- R6Class(classname = "Learner",
                   portable = TRUE,
                   class = TRUE,
                   public = list(
                     params = NULL,
                     initialize = function(...) {
                       params=list(...)
                       if(length(params)==1 && names(params)=="params"){
                         params=params$params
                       }

                       self$params=params

                       invisible(self)
                     },
                     train = function(task) {
                        #trains learner to data
                        assert_that(is(task,"Learner_Task"))

                        #todo: add error handling
                        fit_object = private$.train(task)

                        new_object=self$clone() # copy parameters, and whatever else
                        new_object$set_train(fit_object, task)

                        return(new_object)
                     },

                     set_train = function(fit_object, training_task){
                       #todo: figure out how to do this without a public method that is mutuating private variables.
                       private$.fit_object = fit_object
                       private$.training_task = training_task


                     },

                     predict = function(task = NULL){
                       if(!self$is_trained){
                         stop("Learner has not yet been train to data. Call learner$train(task) first.")
                       }

                       if(is.null(task)){
                         task <- private$.training_task
                       }
                       assert_that(is(task,"Learner_Task"))

                       predictions = private$.predict(task)

                       return(predictions)
                     },

                    chain = function(task = NULL){
                      if(!self$is_trained){
                        stop("Learner has not yet been train to data. Call learner$train(task) first.")
                      }

                      if(is.null(task)){
                        task <- private$.training_task
                      }
                      assert_that(is(task,"Learner_Task"))

                      next_task = private$.chain(task)

                      return(next_task)


                     },
                    print = function(){
                      print(self$name)
                      #print(self$params)
                      fit_object=private$.fit_object
                      if(!is.null(fit_object))
                      print(fit_object)
                    }),
                   active = list(
                     is_trained=function(){
                       return(!is.null(private$.fit_object))
                     },
                     name=function(){
                       #todo: allow custom names
                       if(is.null(private$.name)){

                         params=self$params
                         if(length(params)>0){
                           #todo: sanitize further
                           atom_params=sapply(params,is.atomic)
                           params=params[atom_params]
                         }
                         props = c(list(class(self)[1]), params)
                         name = paste(props,collapse="_")
                         private$.name = name
                       }

                       return(private$.name)
                     }
                   ),
                   private = list(
                     .name = NULL,
                     .fit_object = NULL,
                     .training_task = NULL,
                     .train = function(task){
                       stop("Learner is meant to be abstract, you should instead use specific learners. See listLearners()")
                     },
                     .predict = function(task){
                       predictions = predict(private$.fit_object, newdata=task$X)
                       return(predictions)
                     },
                     .chain = function(task){
                       predictions = self$predict(task)
                       predictions = as.data.table(predictions)
                       colnames(predictions)= paste(self$name,colnames(predictions), sep="_")

                       #now make a new task where these are the covariates

                       return(task$next_in_chain(predictions))
                     }
                   )
)

#todo: implement predict S3 method


print.Learner=function(object){
  object$print()
}